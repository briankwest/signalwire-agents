────────────────────────────────────────────────────────────────────────────
SignalWire AI Agent SDK – High-Level Architecture
────────────────────────────────────────────────────────────────────────────

1. Purpose & Vision
-------------------
Build a Python-based, object-oriented SDK that lets developers create,
host and secure SignalWire AI agents as *micro-services* with almost no
boiler-plate.  
•  Each agent instance is both a web app (serves SWML & SWAIG endpoints)  
   and an AI persona (prompt, tools, memory).  
•  Security, SWML generation, SWAIG plumbing and per-call state are all
   handled by the framework so that subclass authors only implement
   business logic.

2. Layered Model
----------------
    ┌───────────────────────────────┐
    │  Custom Agent Classes         │  (User code)
    ├───────────────────────────────┤
    │  Prefab Archetypes            │  (InfoGatherer, FAQBot, Concierge...)
    ├───────────────────────────────┤
    │  AgentBase                    │  (Prompt builder, SWML, HTTP, auth)
    ├───────────────────────────────┤
    │  Core Helpers & Runtime       │  (SwaigFunction, Result, StateManager)
    └───────────────────────────────┘

3. Core Components
------------------
A. AgentBase  
   •  __init__(name, route, host, port, enable_state_tracking=False, ...) – registers router & auth  
   •  Prompt Building  
      – Structured methods via `prompt_add_section` and `prompt_add_subsection`
      – Raw text prompts (set_prompt_text) for simplicity when needed
      – Declarative PROMPT_SECTIONS for auto-initialization  
   •  SWML Renderer `_render_swml(call_id)`  
      – Serialises prompt, SWAIG registry, post_prompt_url, hooks  
      – Always includes SWAIG array with defaults and state tracking hooks  
   •  Web Interface (`serve`, `as_router`)  
      – GET  /route                → SWML document  
      – POST /route                → SWML with request data processing   
      – POST /route/post_prompt    → summary handler  
      – POST /route/swaig          → SWAIG invocation  
   •  Call-Session Manager  
      – Generates `call_id`, per-function tokens  
      – When state tracking enabled, `startup_hook` activates, `hangup_hook` invalidates session  
   •  State Manager & Tracking  
      – Persistent storage across interactions via get_state, set_state, update_state
      – Auto-expiring state with cleanup  
      – Optional lifecycle hooks via startup_hook and hangup_hook methods
      – Hooks automatically registered when enable_state_tracking=True
      – Automatic state tracking from call initiation to termination
   •  URL Generation & Proxying
      – Supports SWML_PROXY_URL_BASE environment variable for public-facing URLs
      – Automatically replaces local server URL with public proxy URL in all SWML

B. SWAIGFunction  
   •  Declarative descriptor holding `name`, `description`, `parameters`,
      `handler`, `secure` flag.  
   •  SWAIG spec compliant with proper parameter structure (type:object/properties)
   •  Support for optional fillers to provide feedback during processing
   •  `to_swaig(base_url, token, call_id)` returns JSON ready for SWML.  
   •  Decorator style  `@tool(name=…, parameters=…, fillers=…)`.

C. SwaigFunctionResult  
   •  Wrapper around SWAIG response payload.  
   •  `set_response()`, `add_action(name, data)`, `to_dict()`.  
   •  Result format includes `response` text and/or `action` array.
   •  Actions stored in "action" key (singular) with each action as {name: data} object.

D. SwmlRenderer
   •  Handles proper SWML generation according to spec
   •  Always creates a SWAIG array with:
      - A defaults object with web_hook_url
      - startup_hook and hangup_hook functions when needed
      - User-defined SWAIG functions with proper structure
   •  Generates compliant JSON/YAML output

E. Session / Security  
   •  Basic-Auth for SWML + post_prompt endpoints.  
   •  Ephemeral per-call tokens embedded into SWAIG URLs.  
   •  Tokens live from `startup_hook` → `hangup_hook`.

F. Prefab Archetypes  
   •  `InfoGathererAgent(fields=[…], confirmation_template=…)`  
   •  `SurveyAgent`, `FAQBotAgent`, `ConciergeAgent`, etc.  
   •  Supply `PROMPT_SECTIONS`, default tools & summary formats.  
   •  Zero code beyond constructor arguments for most cases.

G. State Management  
   •  Abstract StateManager interface with FileStateManager implementation  
   •  Methods for get_state, set_state, update_state, clear_state  
   •  Automatic state lifecycle with optional tracking:
      – enable_state_tracking=True automatically registers lifecycle hooks
      – startup_hook initializes state when conversation begins 
      – hangup_hook performs cleanup when conversation ends
   •  Time-based expiration with automatic cleanup  

4. Operational Flow
-------------------
1. SignalWire hits  `/agent`  (basic-auth) → SDK returns SWML.  
2. SWML contains:  
      • Prompt (rendered POM or text)  
      • post_prompt_url (basic-auth)  
      • startup/hangup hooks (tokenised URLs)  
      • SWAIG array with per-function tokenised URLs.  
3. startup_hook fires → session marked *active*.  
4. During call AI invokes `/swaig` with token & call_id → SDK
   validates → executes `handler` → returns `SwaigFunctionResult`.  
5. hangup_hook fires → session & tokens purged.  
6. post_prompt summary arrives → `on_summary()` callback runs.

5. Extensibility Points
-----------------------
•  Override any of:  
   – `get_prompt()` or use prompt_add_section/prompt_add_subsection methods  
   – `define_tools()` or decorated methods  
   – `on_summary(summary)`  
   – `startup_hook()` and `hangup_hook()` for state lifecycle  
   – `on_function_call(name, args, raw_data)` for catch-all logic  
•  Prompt building:
   – POM structure via prompt_add_section and prompt_add_subsection
   – Support for nested subsections with title, body and bullets 
   – Automatic parent section creation when needed
•  Plug custom authentication/authorisation by overriding
   `validate_basic_auth()` and `validate_tool_token()`.

6. Deployment Modes
-------------------
A. Single-Agent Microservice  
   ```
   agent = SupportBot()
   agent.serve(host="0.0.0.0", port=8080)
   ```
B. Multi-Agent Host  
   ```
   server = AgentServer()
   server.register(SupportBot(), "/support")
   server.register(SalesBot(),   "/sales")
   server.run()
   ```
   ( `AgentServer` is a thin FastAPI wrapper around multiple
     `agent.as_router()` instances. )

7. Future Enhancements
----------------------
•  RAG connectors, memory stores, analytics hooks.  
•  Auto-documentation / OpenAPI export for all SWAIG tools.  
•  CLI & Cookiecutter templates for rapid new-agent scaffolding.  
•  Pluggable token strategies (JWT, HMAC, one-time-pad).  
•  Built-in LLM unit-testing harness (prompt + mock tool calls).

────────────────────────────────────────────────────────────────────────────
End of Architecture Overview
────────────────────────────────────────────────────────────────────────────
